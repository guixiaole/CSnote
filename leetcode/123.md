# 最长连续序列
## 问题描述
给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 O(n) 的算法解决此问题。
示例 1：

输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
示例 2：

输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
## 解题思路
当面对这种问题的时候，最简单的方法当然是排序，但排序的时间复杂度是O(nlogn)，因此不采用排序的时候，最先想到的应该是使用空间换时间的方式，而当面对乱序的时候，最好的空间不是数组，而是hash表。因此，首先想到的就是hash表。其次，当我们使用hash表的时候，如何才能找到连续的序列呢？为什么不能找到一个最小的值，从而找到所有的序列，（ 最大值也可以）因为中间值的时候，需要向左或者向右进行查找，从而查找能力单一，当我们找到了一组连续序列中的最值，我们因此一直向前找，从而能够找到该序列的最长记录。本次代码使用了HashMap存储，而官方题解中给出了Set，个人觉得Set是最适合本题的数据结构，但自己给出了hash的解题，就没有修改。代码如下：
```Java
class Solution {
    public int longestConsecutive(int[] nums) {
    Map<Integer,Integer> map = new HashMap<>();
        for (int i = 0;i<nums.length;i++){
            map.put(nums[i],0);
        }
        int maxLen =0;
        for(Integer i : map.keySet()){
            if (!map.containsKey(i-1)){
                int last  =i+1;
                int len = 1;
                while (map.containsKey(last)){
                    len++;
                    last++;
                }
                if (len>maxLen){
                    maxLen=len;
                }
            }
        }
        return maxLen;
    }
}
```